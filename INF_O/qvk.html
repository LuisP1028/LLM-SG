<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEURAL_DB // DITHER_VIS</title>
    <style>
        :root {
            --bg: #050505;
            --term-green: #33ff00;
            --term-dim: #113300;
            --ui-bg: rgba(5, 5, 5, 0.9);
            --font-main: 'Courier New', Courier, monospace;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--term-green);
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            user-select: none;
        }

        /* --- CRT OVERLAY --- */
        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
        }
        
        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 101;
        }

        /* --- RESPONSIVE UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 40vh; /* Dedicate top 40% to UI to prevent overlap */
            padding: 2vh 2vw;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Align right */
            gap: 1vh;
            z-index: 10;
            pointer-events: none;
        }

        .panel {
            background: var(--ui-bg);
            border: 1px solid var(--term-green);
            box-shadow: 4px 4px 0px var(--term-dim);
            backdrop-filter: blur(2px);
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            
            /* Responsive Width Logic */
            width: 35vw;
            min-width: 280px;
            max-width: 500px;
        }

        /* LOG PANEL SPECIFICS (Prevent Crushing) */
        #panel-log {
            flex: 2; /* Take up more space */
            min-height: 100px; /* Absolute minimum */
            max-height: 200px;
        }

        #panel-matrix {
            flex: 1;
            min-height: 80px;
        }

        .panel-header {
            background: var(--term-green);
            color: #000;
            padding: 4px 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: clamp(10px, 1.2vh, 12px);
            flex-shrink: 0; /* Header never shrinks */
        }

        #log-container {
            flex-grow: 1; /* Fills remaining space */
            overflow: hidden; /* Hide overflow, don't overlap */
            padding: 8px;
            display: flex;
            flex-direction: column-reverse; /* Newest at bottom visually */
            gap: 4px;
        }

        .log-entry {
            font-size: clamp(11px, 1.2vw, 14px);
            line-height: 1.4em; /* Strict line height */
            border-bottom: 1px dashed var(--term-dim);
            padding-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0; /* Prevent text crushing */
        }

        .log-entry.highlight {
            background: var(--term-dim);
            color: #fff;
        }

        #matrix-content {
            padding: 8px;
            font-size: clamp(10px, 1vw, 12px);
            line-height: 1.2em;
            font-family: monospace;
            white-space: pre;
            overflow: hidden;
        }

        /* --- MOBILE OVERRIDES --- */
        @media (max-width: 600px) {
            #ui-layer {
                align-items: stretch; /* Full width on mobile */
                height: 35vh;
            }
            .panel {
                width: 100%; /* Force full width */
                min-width: 0;
                max-width: none;
            }
            #log-container {
                gap: 2px;
            }
        }
        
        #canvas-wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <div id="panel-log" class="panel">
            <div class="panel-header">SYS.LOG // SEQUENCE_OPS</div>
            <div id="log-container">
                </div>
        </div>
        <div id="panel-matrix" class="panel">
            <div class="panel-header">ATTENTION_MATRIX</div>
            <div id="matrix-content">INITIALIZING...</div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="mainCanvas"></canvas>
    </div>

<script>
/**
 * DITHERPUNK NEURAL VISUALIZER v3 (Window Agnostic)
 */

// --- CONFIGURATION ---
const SENTENCE = "The animal didn't cross the street because it";
const TOKENS_TEXT = SENTENCE.split(" ");
const TARGET_IDX = 7; // "it"
const ATTENTION_WEIGHTS = {
    "The": 0.01, "animal": 0.85, "didn't": 0.02, "cross": 0.05,
    "the": 0.01, "street": 0.15, "because": 0.05, "it": 0.0
};

// --- GLOBAL STATE ---
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let W, H;
let layoutScale = 1;

// Phase Management
const PHASES = { INIT: 0, PROJECTION: 1, SCAN: 2, EXTRACTION: 3, FINALIZE: 4, RESET: 5 };
let state = {
    phase: PHASES.INIT,
    timer: 0,
    scanIndex: 0,
    tokens: [],
    particles: []
};

// --- PATTERN GENERATION (DITHERING) ---
const Patterns = {};

function createDitherPattern(type) {
    const size = 4; // Small tile size for crisp pixel look
    const pCan = document.createElement('canvas');
    pCan.width = size;
    pCan.height = size;
    const pCtx = pCan.getContext('2d');
    
    // Transparent Background by default
    
    pCtx.fillStyle = '#33ff00';

    if (type === 'stripe') {
        // Horizontal Lines (Keys)
        pCtx.fillRect(0, 0, size, 1); 
    } else if (type === 'check') {
        // Checkerboard (Values)
        pCtx.fillRect(0,0,2,2);
        pCtx.fillRect(2,2,2,2);
    } else if (type === 'noise') {
        // Noise (Query)
        pCtx.fillRect(0,0,4,4);
        pCtx.fillStyle = '#000';
        pCtx.fillRect(1,1,1,1);
        pCtx.fillRect(3,0,1,1);
        pCtx.fillRect(0,3,1,1);
    }
    
    return ctx.createPattern(pCan, 'repeat');
}

function initPatterns() {
    Patterns.stripe = createDitherPattern('stripe');
    Patterns.check = createDitherPattern('check');
    Patterns.noise = createDitherPattern('noise');
}

// --- CLASSES ---

class Particle {
    constructor(sx, sy, tx, ty) {
        this.x = sx; this.y = sy;
        this.tx = tx; this.ty = ty;
        this.progress = 0;
        // Speed relates to distance to keep animation timing consistent across sizes
        this.speed = 0.015 + Math.random() * 0.02;
        this.dead = false;
        this.size = (2 + Math.random() * 4) * layoutScale;
        this.wobbleFreq = Math.random() * 0.2;
        this.wobbleAmp = (20 * layoutScale) * (Math.random() > 0.5 ? 1 : -1);
    }

    update() {
        this.progress += this.speed;
        if(this.progress >= 1) { this.progress = 1; this.dead = true; }
        
        // Linear path
        const lx = this.x + (this.tx - this.x) * this.progress;
        const ly = this.y + (this.ty - this.y) * this.progress;
        
        // Sine wobble
        const w = Math.sin(this.progress * Math.PI * 2) * this.wobbleAmp * Math.sin(this.progress * Math.PI);
        
        this.cx = lx + w;
        this.cy = ly;
    }

    draw(ctx) {
        if(this.dead) return;
        ctx.fillStyle = '#33ff00';
        // Draw tiny rects
        ctx.fillRect(this.cx, this.cy, this.size, this.size);
    }
}

class Token {
    constructor(text, index, total) {
        this.text = text;
        this.index = index;
        this.total = total;
        this.isTarget = (index === TARGET_IDX);
        this.score = ATTENTION_WEIGHTS[text] || 0;
        this.contextScale = 0;
        
        // Layout Properties
        this.x = 0; this.y = 0; this.w = 0;
        this.h = 0; 
        
        // Heights of internal blocks
        this.kH = 0; this.vH = 0;
    }

    updateLayout(cw, ch, sc) {
        // Margin: 5% on sides
        const margin = cw * 0.05;
        const availW = cw - (margin * 2);
        
        this.w = availW / this.total;
        this.x = margin + (this.index * this.w);
        this.cx = this.x + (this.w/2);
        
        // Y Position: Anchored to bottom 15%
        this.y = ch * 0.85;
        
        // Dimensions
        this.h = 40 * sc;
        this.kH = 30 * sc;
        this.vH = 35 * sc;
        
        // Font Calculation: Fit text inside box
        // Base font size on Width
        const charWidthEst = this.w / (this.text.length + 1);
        this.fontSize = Math.min(18 * sc, charWidthEst * 1.5);
        this.fontSize = Math.max(8, this.fontSize); // Min floor
    }

    drawBase(ctx) {
        const pad = 4 * layoutScale;
        const bw = this.w - pad;
        
        // Box
        ctx.lineWidth = Math.max(1, 1 * layoutScale);
        ctx.strokeStyle = "#1a4d00";
        ctx.strokeRect(this.x + pad/2, this.y, bw, this.h);
        
        if (this.isTarget) {
            ctx.fillStyle = "rgba(51, 255, 0, 0.15)";
            ctx.fillRect(this.x + pad/2, this.y, bw, this.h);
        }

        // Text
        ctx.fillStyle = this.isTarget ? "#fff" : "#33ff00";
        ctx.font = `${this.isTarget?"bold":""} ${this.fontSize}px monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.text, this.cx, this.y + this.h/2);
    }

    drawArchive(ctx) {
        if (this.isTarget) return;

        const pad = 6 * layoutScale;
        const bw = this.w - pad;
        const gap = 4 * layoutScale;

        // K Block
        const ky = this.y - this.kH - gap;
        ctx.fillStyle = Patterns.stripe;
        ctx.fillRect(this.cx - bw/2, ky, bw, this.kH);
        ctx.strokeStyle = "#33ff00";
        ctx.strokeRect(this.cx - bw/2, ky, bw, this.kH);

        // V Block
        const vy = ky - this.vH - gap;
        ctx.fillStyle = Patterns.check;
        ctx.fillRect(this.cx - bw/2, vy, bw, this.vH);
        ctx.strokeRect(this.cx - bw/2, vy, bw, this.vH);
    }

    drawQuery(ctx, rise) {
        if (!this.isTarget) return;

        const pad = 6 * layoutScale;
        const bw = this.w - pad;
        const qH = 30 * layoutScale;

        // Float Destination: Middle of "Air" zone (approx 60% of screen height)
        const startY = this.y;
        const endY = H * 0.6; 
        
        const curY = startY - ((startY - endY) * rise);
        
        this.qBox = { x: this.cx - bw/2, y: curY, w: bw, h: qH };

        ctx.fillStyle = Patterns.noise;
        ctx.fillRect(this.qBox.x, this.qBox.y, bw, qH);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(this.qBox.x, this.qBox.y, bw, qH);
        
        // Q Label
        ctx.fillStyle = "#000";
        ctx.font = `bold ${this.fontSize}px monospace`;
        ctx.fillText("Q", this.cx, curY + qH/2);
    }

    drawContext(ctx) {
        if(this.contextScale <= 0.01) return;
        
        const pad = 6 * layoutScale;
        const bw = this.w - pad;
        const maxH = 60 * layoutScale;
        const h = maxH * this.contextScale;
        
        // Positioned just above the Query Float position
        const base = H * 0.6 - (10 * layoutScale);
        const y = base - h;
        
        ctx.fillStyle = Patterns.check;
        ctx.fillRect(this.cx - bw/2, y, bw, h);
        
        // Shimmer
        if (Math.random() > 0.8) {
             ctx.fillStyle = "rgba(255,255,255,0.5)";
             ctx.fillRect(this.cx - bw/2, y, bw, h);
        }

        ctx.strokeStyle = "#fff";
        ctx.strokeRect(this.cx - bw/2, y, bw, h);
    }
}

// --- SYSTEM FUNCTIONS ---

function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;

    // SCALING LOGIC
    // We want the visualization to look good on 320px width and 2560px width.
    // We use the smaller dimension to drive scale, but clamped.
    const rawScale = Math.min(W / 800, H / 800);
    layoutScale = Math.max(0.6, Math.min(rawScale, 1.5)); // Clamp scale 0.6x to 1.5x

    state.tokens.forEach(t => t.updateLayout(W, H, layoutScale));
}

function log(msg, highlight=false) {
    const el = document.getElementById('log-container');
    const div = document.createElement('div');
    div.className = `log-entry${highlight ? ' highlight' : ''}`;
    
    const d = new Date();
    const ts = `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}:${d.getSeconds().toString().padStart(2,'0')}`;
    
    div.innerHTML = `<span style="opacity:0.6">[${ts}]</span> ${msg}`;
    el.prepend(div);
    
    // Cleanup: Keep only 20 items in DOM to prevent memory leak
    if(el.children.length > 20) el.removeChild(el.lastChild);
}

function updateMatrix() {
    const el = document.getElementById('matrix-content');
    let str = "";
    state.tokens.forEach(t => {
        if(t.isTarget) return;
        const isScan = (state.phase === PHASES.SCAN && state.scanIndex === t.index);
        const marker = isScan ? ">" : " ";
        // Format: "> anim : 0.85"
        // Pad text to align colons
        const txt = t.text.substring(0,5).padEnd(5);
        str += `${marker} ${txt} : ${t.score.toFixed(2)}\n`;
    });
    el.innerText = str;
}

function nextPhase(p) {
    state.phase = p;
    state.timer = 0;
    
    if (p === PHASES.PROJECTION) log("TOKEN 'it': VECTORIZING QUERY...", true);
    if (p === PHASES.SCAN) {
        state.scanIndex = 0;
        log("SCANNING KEY VECTORS...", true);
    }
    if (p === PHASES.EXTRACTION) {
        log("RETRIEVING VALUES...", true);
        spawnParticles();
    }
    if (p === PHASES.FINALIZE) log("CONTEXT UPDATED.", true);
    if (p === PHASES.RESET) {
        log("--- SEQUENCE COMPLETE ---");
        state.particles = [];
        state.tokens[TARGET_IDX].contextScale = 0;
        setTimeout(() => nextPhase(PHASES.PROJECTION), 1000);
    }
}

function spawnParticles() {
    const tgt = state.tokens[TARGET_IDX];
    state.tokens.forEach(t => {
        if(t.isTarget || t.score < 0.05) return;
        
        const count = Math.floor(t.score * 40);
        // Source: Top of V block
        const sy = t.y - t.kH - t.vH - (10*layoutScale);
        // Dest: Target Query Box
        const dy = tgt.qBox.y; 
        
        for(let i=0; i<count; i++) {
            const p = new Particle(t.cx, sy, tgt.cx, dy);
            // Stagger start
            p.progress = -(Math.random() * 0.5); 
            state.particles.push(p);
        }
    });
}

// --- DRAW LOOP ---

function draw() {
    // Clear
    ctx.clearRect(0, 0, W, H); // Transparent clear (bg is handled by CSS)

    const target = state.tokens[TARGET_IDX];

    // 1. Draw Passive
    state.tokens.forEach(t => {
        t.drawBase(ctx);
        t.drawArchive(ctx);
        t.drawContext(ctx);
    });

    // 2. Logic
    if (state.phase === PHASES.PROJECTION) {
        state.timer += 0.02;
        target.drawQuery(ctx, Math.min(state.timer, 1));
        if (state.timer > 1.2) nextPhase(PHASES.SCAN);
    }
    else if (state.phase === PHASES.SCAN) {
        target.drawQuery(ctx, 1);
        state.timer += 0.05;
        
        // Scan cadence
        if (state.timer > 1) {
            state.timer = 0;
            const t = state.tokens[state.scanIndex];
            // Log interaction
            const hit = t.score > 0.1;
            log(`QÂ·K(${t.text}) = ${t.score} ${hit?"[MATCH]":""}`, hit);
            
            state.scanIndex++;
            if (state.scanIndex >= TARGET_IDX) nextPhase(PHASES.EXTRACTION);
        }
        
        updateMatrix();
        
        // Render Scan Beam
        const curr = state.tokens[state.scanIndex];
        if (curr) {
            // Ghost Q over K
            const gy = curr.y - curr.kH - (50 * layoutScale);
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.setLineDash([2, 4]);
            ctx.strokeRect(curr.cx - target.w/2, gy, target.w, 20*layoutScale);
            ctx.setLineDash([]);
            
            // Beam
            ctx.beginPath();
            ctx.moveTo(curr.cx, gy + 20*layoutScale);
            ctx.lineTo(curr.cx, curr.y - curr.kH);
            const intense = curr.score > 0.1;
            ctx.lineWidth = (intense ? 3 : 1) * layoutScale;
            ctx.strokeStyle = intense ? "#fff" : "#1a4d00";
            ctx.stroke();
            
            if(intense) {
                ctx.fillStyle = "#fff";
                ctx.fillText(`${(curr.score*100).toFixed(0)}%`, curr.cx + (15*layoutScale), gy + (30*layoutScale));
            }
        }
    }
    else if (state.phase === PHASES.EXTRACTION) {
        target.drawQuery(ctx, 1);
        updateMatrix();
        
        let active = 0;
        state.particles.forEach(p => {
            if(!p.dead) {
                if(p.progress >= 0) {
                    p.update();
                    p.draw(ctx);
                } else {
                    p.progress += 0.05;
                }
                active++;
            }
        });
        
        // Grow Context
        state.timer += 0.01;
        target.contextScale = Math.min(state.timer, 1);
        
        if(active === 0 && state.timer > 1) nextPhase(PHASES.FINALIZE);
    }
    else if (state.phase === PHASES.FINALIZE) {
        target.drawQuery(ctx, 1);
        state.timer += 0.01;
        if(state.timer > 2) nextPhase(PHASES.RESET);
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

// Bootstrap
initPatterns();
TOKENS_TEXT.forEach((t, i) => {
    state.tokens.push(new Token(t, i, TOKENS_TEXT.length));
});

window.addEventListener('resize', resize);
resize(); // Initial calc
log("SYSTEM ONLINE.");
setTimeout(() => nextPhase(PHASES.PROJECTION), 1000);
loop();

</script>
</body>
</html>