<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LoRA Protocol: Adaptive Visualization</title>
    <style>
        :root {
            --bg-color: #080808;
            --fg-color: #00FF41;
            --dim-color: #003B0F;
            --term-bg: rgba(0, 15, 5, 0.90);
            --border-color: #008F24;
            /* Responsive spacing vars */
            --spacing-unit: clamp(15px, 3vw, 30px);
            --font-base: clamp(12px, 2vw, 16px);
        }
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--fg-color);
            user-select: none;
            -webkit-font-smoothing: none;
        }

        /* --- LAYOUT CONTAINER --- */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        /* --- HEADER UI --- */
        #header-layer {
            position: absolute;
            top: var(--spacing-unit);
            left: var(--spacing-unit);
            z-index: 5;
            pointer-events: none;
            max-width: 90%;
        }

        h1 {
            font-size: clamp(1.2rem, 4vw, 2rem);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-bottom: 2px solid var(--fg-color);
            padding-bottom: 0.2em;
            display: inline-block;
            text-shadow: 0 0 8px var(--dim-color);
            background: rgba(8,8,8,0.7);
        }

        .phase-badge {
            margin-top: 0.8em;
            background: var(--fg-color);
            color: var(--bg-color);
            padding: 0.3em 0.8em;
            font-weight: 900;
            font-size: clamp(0.8rem, 2.5vw, 1.1rem);
            display: inline-block;
            box-shadow: 0.2em 0.2em 0px var(--dim-color);
        }

        /* --- TERMINAL LOG (Responsive) --- */
        #terminal-container {
            position: absolute;
            bottom: var(--spacing-unit);
            left: var(--spacing-unit);
            width: clamp(280px, 40vw, 500px);
            max-height: 40vh;
            background: var(--term-bg);
            border: 1px solid var(--border-color);
            z-index: 20;
            box-shadow: 6px 6px 0px #001a05;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        /* Mobile Adjustment for Terminal */
        @media (max-width: 768px) {
            #terminal-container {
                width: calc(100% - (var(--spacing-unit) * 2));
                bottom: calc(var(--spacing-unit) + 60px); /* Make room for button */
                box-shadow: 4px 4px 0px #001a05;
            }
        }

        #term-header {
            background: var(--dim-color);
            color: var(--fg-color);
            padding: 0.5em 1em;
            font-size: 0.8rem;
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
        }

        #term-body {
            padding: 1em;
            font-size: var(--font-base);
            line-height: 1.4;
            white-space: pre-wrap;
            overflow-y: auto;
            /* Custom Scrollbar for Webkit */
            scrollbar-width: thin;
            scrollbar-color: var(--fg-color) var(--bg-color);
        }

        #term-body::-webkit-scrollbar { width: 6px; }
        #term-body::-webkit-scrollbar-thumb { background: var(--fg-color); }
        #term-body::-webkit-scrollbar-track { background: var(--bg-color); }

        .cursor {
            display: inline-block;
            width: 0.6em;
            height: 1.2em;
            background: var(--fg-color);
            vertical-align: text-bottom;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- BUTTON CONTROLS --- */
        #controls {
            position: absolute;
            bottom: var(--spacing-unit);
            right: var(--spacing-unit);
            z-index: 20;
        }

        /* On mobile, center the button at very bottom */
        @media (max-width: 768px) {
            #controls {
                left: var(--spacing-unit);
                right: var(--spacing-unit);
                bottom: var(--spacing-unit);
                display: flex;
            }
            button {
                width: 100%;
            }
        }

        button {
            background: var(--bg-color);
            border: 2px solid var(--fg-color);
            color: var(--fg-color);
            padding: 0.8em 1.5em;
            font-family: inherit;
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 4px 4px 0px var(--dim-color);
            transition: transform 0.1s, box-shadow 0.1s;
            white-space: nowrap;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px var(--dim-color);
        }

        /* --- RETRO OVERLAY --- */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.3) 50%,
                rgba(0,0,0,0.3)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="header-layer">
        <h1>LoRA Visualization</h1><br>
        <div id="phase-badge" class="phase-badge">SYSTEM INITIALIZED</div>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div id="terminal-container">
        <div id="term-header">
            <span>SYS.LOG</span>
            <span>:: EXEC_MODE</span>
        </div>
        <div id="term-body"><span id="typewriter-text"></span><span class="cursor"></span></div>
    </div>

    <div id="scanlines"></div>

    <div id="controls">
        <button id="nextBtn">START PROCESS >></button>
    </div>

    <script>
        /**
         * RESPONSIVE LORA VISUALIZER
         * Scale-agnostic logic for Ditherpunk Aesthetic
         */

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const phaseBadge = document.getElementById('phase-badge');
        const typeTextSpan = document.getElementById('typewriter-text');
        const nextBtn = document.getElementById('nextBtn');

        // Theme Constants
        const C_BG = '#080808';
        const C_FG = '#00FF41'; 
        const C_ERR = '#FF0055'; 
        const C_WHT = '#EEFFEE';

        // State
        let width, height;
        let frame = 0;
        let stepIndex = 0;
        
        // Logical Step Definitions
        const STEPS = [
            {
                title: "1. BASE MODEL PREPARATION",
                log: "> ACTION: Load Pre-trained Base Model.\n> OPTIMIZATION: Quantize to 4-bit (Save Memory).\n> STATE: WEIGHTS FROZEN. No parameter updates allowed.\n> NOTE: Simulates massive neural network structure."
            },
            {
                title: "2. CONFIGURATION (ONTOLOGY)",
                log: "> DEFINE: LoraConfig Object.\n> R (RANK)=8: Sets bottleneck size.\n> ALPHA=16: Scaling factor.\n> TARGETS: Attaching adapters to Linear layers (q_proj, v_proj).\n> VISUAL: Matrix A compresses (d→r), Matrix B expands (r→d)."
            },
            {
                title: "3. MODEL INJECTION",
                log: "> INJECTING: Parallel Adapter Structure.\n> LOGIC: The small orange path runs ALONGSIDE the frozen blue path.\n> INIT: Weights set to Zero/Gaussian.\n> RESULT: Total trainable params < 1%."
            },
            {
                title: "4. TRAINING (FINE-TUNING)",
                log: "> PROCESS: Backpropagation.\n> MECHANISM: Gradients (Red) bypass the frozen block.\n> UPDATE: Only Matrices A & B are modified.\n> BENEFIT: No Catastrophic Forgetting of base knowledge."
            },
            {
                title: "5. MERGING & INFERENCE",
                log: "> DEPLOYMENT: Merging Adapter into Base.\n> MATH: W_final = W_base + (B × A × α/r).\n> RESULT: Single optimized model structure.\n> LATENCY: Zero additional overhead."
            }
        ];

        // Entity State Objects
        // Positions are calculated in resize()
        let baseModel = { frozen: false, scanLine: 0 };
        let adapterA = { opacity: 0 };
        let adapterB = { opacity: 0 };
        let mergeProgress = 0;
        let particles = [];

        // Pre-rendered Patterns
        let noisePat, gridPat, densePat, stripePat;
        // Typewriter State
        let typeTarget = "";
        let typeIdx = 0;

        /**
         * RESPONSIVE GEOMETRY CALCULATION
         * This ensures visual consistency across Mobile (Portrait) and Desktop (Landscape)
         */
        function resize() {
            // Get actual display size in pixels
            width = canvas.parentElement.clientWidth;
            height = canvas.parentElement.clientHeight;
            
            // Update Canvas Resolution
            canvas.width = width;
            canvas.height = height;
            
            // Determine orientation
            const isPortrait = height > width;
            const cx = width / 2;
            const cy = height / 2;
            
            // Reference Unit: Min dimension to ensure square-ish elements don't stretch
            const ref = Math.min(width, height);

            // Calculate Base Model Dimensions
            // Landscape: wider blocks. Portrait: narrower blocks.
            const bW = isPortrait ? width * 0.35 : width * 0.15;
            const bH = isPortrait ? height * 0.40 : height * 0.55;
            
            // Clamp max size for ultra-wide monitors
            const maxW = 200; 
            const clampedBW = Math.min(bW, maxW);
            
            baseModel.w = clampedBW;
            baseModel.h = bH;
            
            // Position Base Model
            // Shift left to make room for adapter
            const xOffset = isPortrait ? clampedBW * 0.8 : clampedBW * 1.2;
            baseModel.x = cx - xOffset; 
            baseModel.y = cy - (bH / 2);

            // Calculate Adapter Dimensions (Relative to Base)
            const aW = clampedBW * 0.6; // Adapter width relative to base
            const aH = bH * 0.15;       // Matrix height relative to base
            
            // Adapter Gap
            const gap = isPortrait ? width * 0.05 : width * 0.05; 
            const adapterX = baseModel.x + baseModel.w + gap;
            
            adapterA.w = aW; 
            adapterA.h = aH;
            adapterA.x = adapterX;
            adapterA.y = baseModel.y + bH - aH; // Bottom Matrix (Compress)

            adapterB.w = aW;
            adapterB.h = aH;
            adapterB.x = adapterX;
            adapterB.y = baseModel.y; // Top Matrix (Expand)

            createPatterns();
        }

        // --- PATTERN GENERATION (Window Agnostic) ---
        function createPatterns() {
            const mkPat = (draw) => {
                const c = document.createElement('canvas');
                c.width = 8; c.height = 8; // Pattern tile size
                draw(c.getContext('2d'));
                return ctx.createPattern(c, 'repeat');
            };

            // 1. Noise (Unfrozen)
            noisePat = mkPat(c => {
                c.fillStyle = C_BG; c.fillRect(0,0,8,8);
                c.fillStyle = '#003300';
                for(let i=0; i<12; i++) c.fillRect(Math.random()*8, Math.random()*8, 1, 1);
            });

            // 2. Grid (Frozen)
            gridPat = mkPat(c => {
                c.fillStyle = C_BG; c.fillRect(0,0,8,8);
                c.strokeStyle = '#004411'; c.lineWidth = 1;
                c.strokeRect(0.5,0.5,7,7);
                c.fillStyle = '#001a05'; c.fillRect(2,2,4,4);
            });

            // 3. Dense (Merged)
            densePat = mkPat(c => {
                c.fillStyle = '#00220a'; c.fillRect(0,0,8,8);
                c.fillStyle = C_FG; c.fillRect(1,1,1,1); c.fillRect(5,5,1,1);
            });

            // 4. Adapter (Active)
            stripePat = mkPat(c => {
                c.fillStyle = C_BG; c.fillRect(0,0,8,8);
                c.strokeStyle = C_FG;
                c.beginPath(); c.moveTo(0,8); c.lineTo(8,0); c.stroke();
            });
        }

        // --- STATE MANAGEMENT ---
        function setStep(idx) {
            stepIndex = idx;
            phaseBadge.textContent = STEPS[idx].title;
            typeTarget = STEPS[idx].log;
            typeIdx = 0;
            typeTextSpan.textContent = "";
            
            // Reset Visual State
            if(idx === 0) {
                baseModel.scanLine = 0;
                baseModel.frozen = false;
                adapterA.opacity = 0;
                adapterB.opacity = 0;
                mergeProgress = 0;
            }
        }

        function updateTypewriter() {
            if (typeIdx < typeTarget.length) {
                // Type 3 chars per frame for responsive feel
                for(let i=0; i<3; i++) {
                    if(typeIdx < typeTarget.length) {
                        typeTextSpan.textContent += typeTarget.charAt(typeIdx);
                        typeIdx++;
                    }
                }
            }
        }

        // --- DRAWING HELPERS ---
        function drawRect(x, y, w, h, pat, stroke=true, glow=false) {
            ctx.fillStyle = pat;
            ctx.fillRect(x,y,w,h);
            if(stroke) {
                ctx.strokeStyle = glow ? C_WHT : C_FG;
                ctx.lineWidth = glow ? 3 : 2;
                ctx.strokeRect(x,y,w,h);
            }
        }

        function drawConnector(x1, y1, x2, y2) {
            ctx.strokeStyle = C_FG;
            ctx.setLineDash([4,4]);
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawParticles() {
            const isTraining = (stepIndex === 3);
            const isForward = (stepIndex === 2);

            if (!isTraining && !isForward) {
                particles = [];
                return;
            }

            // Spawn Rate
            if(Math.random() > 0.8) {
                const spawnY = isTraining ? -20 : height + 20;
                const speed = isTraining ? height * 0.015 : -(height * 0.015); // Scale speed by height
                
                // Main Stream
                particles.push({
                    x: baseModel.x + baseModel.w/2 + (Math.random()*baseModel.w*0.2 - baseModel.w*0.1),
                    y: spawnY,
                    vx: 0,
                    vy: speed, 
                    type: 'main',
                    life: 200
                });
                
                // Adapter Stream
                particles.push({
                    x: adapterA.x + adapterA.w/2 + (Math.random()*adapterA.w*0.4 - adapterA.w*0.2),
                    y: spawnY,
                    vx: 0,
                    vy: speed,
                    type: 'bypass',
                    life: 200
                });
            }

            // Update & Draw
            for (let i = particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.y += p.vy;
                p.life--;

                let color = C_FG;
                const pSize = Math.max(2, width * 0.003); // Responsive particle size

                if (isTraining) {
                    color = C_ERR; 
                    
                    // Bounce off Frozen Model
                    if(p.type === 'main') {
                        if(p.y > baseModel.y && p.y < baseModel.y + baseModel.h) {
                            p.vy *= -1; 
                            p.vx = (Math.random()-0.5) * (width * 0.02);
                            p.life = 15;
                        }
                    }
                    
                    // Absorb in Adapter
                    if(p.type === 'bypass') {
                        if(p.y > adapterB.y && p.y < adapterA.y + adapterA.h) {
                            color = C_WHT; 
                            // Spark effect
                            if(Math.random()>0.7) {
                                ctx.fillStyle = C_WHT;
                                ctx.fillRect(p.x - pSize*2, p.y, pSize*4, pSize);
                            }
                        }
                    }
                }

                ctx.fillStyle = color;
                ctx.fillRect(p.x, p.y, pSize, pSize);
                
                if(p.life <= 0 || p.y < -50 || p.y > height + 50) particles.splice(i,1);
            }
        }

        // --- MAIN ANIMATION LOOP ---
        function loop() {
            frame++;
            updateTypewriter();

            // Clear Canvas
            ctx.fillStyle = C_BG;
            ctx.fillRect(0,0,width,height);

            // --- ANIMATION LOGIC ---
            
            // 1. Base Model Scan
            if (stepIndex === 0) {
                const scanSpeed = baseModel.h * 0.02;
                if (baseModel.scanLine < baseModel.h) baseModel.scanLine += scanSpeed;
                else baseModel.frozen = true;
            } else {
                baseModel.scanLine = baseModel.h; 
                baseModel.frozen = true;
            }

            // 2. Adapter Fade In
            let showAdapters = stepIndex >= 1 && stepIndex !== 4; 
            let targetOpacity = showAdapters ? 1 : 0;
            
            if (stepIndex !== 4) {
                adapterA.opacity += (targetOpacity - adapterA.opacity) * 0.1;
                adapterB.opacity = adapterA.opacity;
            }

            // 3. Merge Logic
            let renderBaseX = baseModel.x;
            let renderAdapterX = adapterA.x;
            
            if (stepIndex === 4) {
                // Determine destination
                let dist = adapterA.x - baseModel.x;
                let speed = dist * 0.05;
                if (mergeProgress < dist) mergeProgress += speed;
                renderAdapterX -= mergeProgress;
                
                if (mergeProgress > dist * 0.8) {
                    adapterA.opacity = Math.max(0, adapterA.opacity - 0.05);
                    adapterB.opacity = adapterA.opacity;
                }
            }

            // --- RENDER OBJECTS ---

            // Draw Base
            let mPat = baseModel.frozen ? gridPat : noisePat;
            if (stepIndex === 4 && adapterA.opacity <= 0.1) mPat = densePat;
            drawRect(renderBaseX, baseModel.y, baseModel.w, baseModel.h, mPat);

            // Draw Scanline
            if (stepIndex === 0 && baseModel.scanLine < baseModel.h) {
                ctx.fillStyle = C_FG;
                ctx.fillRect(baseModel.x, baseModel.y + baseModel.scanLine, baseModel.w, height * 0.005);
            }

            // Draw Adapters
            if (adapterA.opacity > 0.01) {
                ctx.save();
                ctx.globalAlpha = adapterA.opacity;
                
                let glow = (stepIndex === 3 && frame % 10 < 5);
                
                drawRect(renderAdapterX, adapterB.y, adapterB.w, adapterB.h, stripePat, true, glow);
                drawRect(renderAdapterX, adapterA.y, adapterA.w, adapterA.h, stripePat, true, glow);

                // Rank Neck (Hourglass)
                const neckTop = adapterB.y + adapterB.h;
                const neckBot = adapterA.y;
                const midX = renderAdapterX + adapterA.w/2;
                
                ctx.strokeStyle = glow ? C_WHT : C_FG;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(renderAdapterX, neckTop); 
                ctx.lineTo(midX - 3, (neckTop+neckBot)/2); 
                ctx.lineTo(renderAdapterX, neckBot);
                ctx.moveTo(renderAdapterX + adapterA.w, neckTop); 
                ctx.lineTo(midX + 3, (neckTop+neckBot)/2); 
                ctx.lineTo(renderAdapterX + adapterA.w, neckBot);
                ctx.stroke();

                // Labels
                if(stepIndex === 1) {
                    ctx.fillStyle = C_FG;
                    ctx.font = `bold ${Math.max(10, width*0.01)}px Courier`;
                    ctx.fillText("r=8", midX + 8, (neckTop+neckBot)/2 + 4);
                }

                ctx.restore();
            }

            // Connectors
            if (stepIndex >= 2 && stepIndex !== 4) {
                const offset = height * 0.05;
                const inY = baseModel.y + baseModel.h + offset;
                const outY = baseModel.y - offset;
                
                drawConnector(baseModel.x + baseModel.w/2, inY, adapterA.x + adapterA.w/2, inY);
                drawConnector(baseModel.x + baseModel.w/2, outY, adapterB.x + adapterB.w/2, outY);
                
                // Sum Node
                ctx.fillStyle = C_FG;
                ctx.font = `bold ${Math.max(16, width*0.02)}px Courier`;
                ctx.textAlign = "center";
                ctx.fillText("+", (baseModel.x + adapterA.x)/2 + baseModel.w/2, outY);
            }

            drawParticles();
            requestAnimationFrame(loop);
        }

        // --- INITIALIZATION ---
        window.addEventListener('resize', resize);
        
        nextBtn.addEventListener('click', () => {
            let nextStep = stepIndex + 1;
            if(nextStep >= STEPS.length) nextStep = 0;
            setStep(nextStep);
            
            if(nextStep === 0) nextBtn.textContent = "START PROCESS >>";
            else if(nextStep === 4) nextBtn.textContent = "RESET SIMULATION";
            else nextBtn.textContent = "NEXT PHASE >>";
        });

        // Boot
        resize();
        setStep(0);
        loop();

    </script>
</body>
</html>