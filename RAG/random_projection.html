<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RP: Dimensional Shadow // Ditherpunk</title>
    <style>
        :root {
            --term-green: #33FF00;
            --term-black: #050505;
            --term-dim: #1a8000;
            --font-stack: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            background-color: var(--term-black);
            font-family: var(--font-stack);
            color: var(--term-green);
            user-select: none;
            
            /* Flexbox Layout: Split screen */
            display: flex;
            flex-direction: row; /* Default: Side-by-side */
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        /* 1. UI SIDEBAR / HEADER */
        #ui-layer {
            position: relative; /* Part of flow, not absolute */
            z-index: 2;
            
            /* Dimensions */
            width: clamp(320px, 30vw, 420px);
            height: 100%;
            flex-shrink: 0; /* Never shrink below min-width */
            
            /* Scrolling & Padding */
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            
            /* Styling */
            background: linear-gradient(180deg, rgba(10,10,10,1) 0%, rgba(0,0,0,0.95) 100%);
            border-right: 2px solid var(--term-dim);
            box-shadow: 10px 0 20px rgba(0,0,0,0.5);
            
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* 2. 3D CANVAS CONTAINER */
        #canvas-container {
            position: relative;
            flex-grow: 1; /* Takes all remaining space */
            height: 100%;
            width: auto;
            z-index: 1;
            overflow: hidden;
            background-color: var(--term-black);
        }

        /* Typography & Elements */
        h1 {
            font-size: 1.8rem;
            text-transform: uppercase;
            border-bottom: 2px solid var(--term-green);
            display: inline-block;
            margin: 0 0 0.5rem 0;
            text-shadow: 0 0 8px var(--term-green);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 0.8rem;
            color: #888;
            display: block;
        }

        .panel-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .status-line {
            border-bottom: 1px dashed var(--term-dim); 
            padding-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            gap: 1rem;
        }

        .bar-container {
            flex-grow: 1;
            height: 12px;
            background: #111;
            border: 1px solid var(--term-dim);
        }

        .bar-fill {
            height: 100%;
            background: var(--term-green);
            width: 0%;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 4px var(--term-green);
        }

        .obs-text {
            font-size: 0.8rem; 
            line-height: 1.4; 
            color: #aaa;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-left: 2px solid var(--term-dim);
        }

        button {
            background: #000;
            color: var(--term-green);
            border: 2px solid var(--term-green);
            padding: 1rem;
            font-family: var(--font-stack);
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0px var(--term-dim);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px var(--term-dim);
        }

        button:hover {
            background: var(--term-green);
            color: #000;
        }

        /* Scanlines Overlay (Fixed on top of everything) */
        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }

        /* MOBILE LAYOUT CHANGE */
        @media (max-width: 800px) {
            body {
                flex-direction: column; /* Stack vertically */
            }

            #ui-layer {
                width: 100%;
                height: auto; /* Hug content */
                max-height: 40vh; /* Don't take more than 40% of screen */
                border-right: none;
                border-bottom: 2px solid var(--term-dim);
                flex-direction: row; /* Horizontal layout for header if possible? */
                flex-wrap: wrap;
                align-items: center;
                padding: 15px;
            }

            /* Adjust internal layout for compact mobile header */
            .header-group {
                margin-right: auto;
                margin-bottom: 10px;
            }

            .panel-content {
                width: 100%;
                gap: 0.5rem;
            }
            
            .obs-text {
                display: none; /* Hide verbose text on mobile to save space */
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="scanlines"></div>

    <!-- UI SIDEBAR / HEADER -->
    <div id="ui-layer">
        <div class="header-group">
            <h1>Dimensional Shadow</h1>
            <span class="subtitle">// RANDOM PROJECTION VISUALIZER</span>
        </div>

        <div class="panel-content">
            <div class="status-line">STATUS: <span id="status-text">ONLINE</span></div>
            
            <div class="stat-row">
                <span>High-D Dist:</span>
                <div class="bar-container"><div id="bar-high" class="bar-fill"></div></div>
            </div>
            <div class="stat-row">
                <span>Low-D Dist:</span>
                <div class="bar-container"><div id="bar-low" class="bar-fill"></div></div>
            </div>
            <div class="stat-row" style="justify-content: center; color: #fff;">
                <span id="ratio-text">Ratio: 1.00</span>
            </div>

            <p class="obs-text">
                > OBSERVATION: Even as the matrix rotates, the relative distance between neighbors remains stable in the shadow projection.
            </p>

            <button id="btn-reroll">[ RE-INITIALIZE MATRIX ]</button>
        </div>
    </div>

    <!-- 3D CANVAS CONTAINER -->
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const LAYER_HIGH_Y = 6;
        const LAYER_MATRIX_Y = 0;
        const LAYER_LOW_Y = -6;
        const POINT_COUNT = 16;
        
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        // Camera
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const renderTarget = new THREE.WebGLRenderTarget(1, 1);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        // --- SCENE ---
        const groupHigh = new THREE.Group();
        const groupMatrix = new THREE.Group();
        const groupLow = new THREE.Group();
        scene.add(groupHigh); scene.add(groupMatrix); scene.add(groupLow);

        // Wireframe Cube
        const cubeGeo = new THREE.BoxGeometry(8, 6, 8);
        const wireCube = new THREE.LineSegments(new THREE.WireframeGeometry(cubeGeo), new THREE.LineBasicMaterial({ color: 0x888888 }));
        wireCube.position.y = LAYER_HIGH_Y;
        groupHigh.add(wireCube);

        // Matrix Plane
        const matCanvas = document.createElement('canvas');
        matCanvas.width = 512; matCanvas.height = 512;
        const matCtx = matCanvas.getContext('2d');
        const matrixTexture = new THREE.CanvasTexture(matCanvas);
        const matrixPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(12, 12), 
            new THREE.MeshBasicMaterial({ map: matrixTexture, transparent: true, opacity: 0.7, side: THREE.DoubleSide })
        );
        matrixPlane.position.y = LAYER_MATRIX_Y;
        matrixPlane.rotation.x = -Math.PI / 2;
        groupMatrix.add(matrixPlane);

        // Floor
        const gridHelper = new THREE.GridHelper(20, 20, 0x666666, 0x222222);
        gridHelper.position.y = LAYER_LOW_Y;
        groupLow.add(gridHelper);

        // Data Points
        const pointsData = [];
        const sphereGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const sphereMat = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });
        const shadowGeo = new THREE.CircleGeometry(0.3, 16);
        const shadowMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const dashMat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 0.5, gapSize: 0.2 });
        const lineHigh = new THREE.Line(new THREE.BufferGeometry(), dashMat);
        const lineLow = new THREE.Line(new THREE.BufferGeometry(), dashMat);
        groupHigh.add(lineHigh);
        lineLow.rotation.x = -Math.PI/2; 
        lineLow.position.y = LAYER_LOW_Y + 0.05;
        groupLow.add(lineLow);

        for(let i=0; i<POINT_COUNT; i++) {
            const x = (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 4;
            const z = (Math.random() - 0.5) * 6;
            
            const meshHigh = new THREE.Mesh(sphereGeo, sphereMat);
            meshHigh.position.set(x,y,z);
            const meshLow = new THREE.Mesh(shadowGeo, shadowMat);
            meshLow.rotation.x = -Math.PI/2; meshLow.position.y = LAYER_LOW_Y;
            
            const rayLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
                (i<2) ? dashMat : new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
            );
            if(i<2) rayLine.computeLineDistances();

            pointsData.push({ basePos: new THREE.Vector3(x,y,z), meshHigh, meshLow, rayLine, isHighlight: i<2 });
            wireCube.add(meshHigh); scene.add(meshLow); scene.add(rayLine);
        }

        // --- ANIMATION & LOGIC ---
        let projectionQuaternion = new THREE.Quaternion();
        let targetQuaternion = new THREE.Quaternion();

        function randomizeMatrix() {
            const euler = new THREE.Euler((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
            targetQuaternion.setFromEuler(euler);
            const btn = document.getElementById('btn-reroll');
            btn.innerHTML = "[ UPDATING... ]"; btn.style.background = "#fff"; btn.style.color = "#000";
            setTimeout(() => { btn.innerHTML = "[ RE-INITIALIZE MATRIX ]"; btn.style.background = ""; btn.style.color = ""; }, 200);
        }

        function updateProjection() {
            projectionQuaternion.slerp(targetQuaternion, 0.05);
            wireCube.quaternion.copy(projectionQuaternion);
            
            let p1, p2, p1_l, p2_l;
            
            pointsData.forEach((p, idx) => {
                const vec = p.basePos.clone().applyQuaternion(projectionQuaternion);
                const worldHigh = new THREE.Vector3();
                p.meshHigh.getWorldPosition(worldHigh);
                const shadowPos = new THREE.Vector3(worldHigh.x, LAYER_LOW_Y + 0.02, worldHigh.z);
                p.meshLow.position.copy(shadowPos);
                
                p.rayLine.geometry.setFromPoints([worldHigh, shadowPos]);
                if(p.isHighlight) p.rayLine.computeLineDistances();

                if(idx===0) { p1 = worldHigh; p1_l = shadowPos; }
                if(idx===1) { p2 = worldHigh; p2_l = shadowPos; }
            });

            if(p1 && p2) {
                lineHigh.geometry.setFromPoints([p1, p2]); lineHigh.computeLineDistances();
                const posLow = new Float32Array([p1_l.x, LAYER_LOW_Y+0.1, p1_l.z, p2_l.x, LAYER_LOW_Y+0.1, p2_l.z]);
                lineLow.geometry.setAttribute('position', new THREE.BufferAttribute(posLow, 3));
                lineLow.rotation.set(0,0,0); lineLow.position.set(0,0,0); lineLow.computeLineDistances();
                
                const dHigh = p1.distanceTo(p2);
                const dLow = Math.sqrt(Math.pow(p1_l.x - p2_l.x, 2) + Math.pow(p1_l.z - p2_l.z, 2));
                
                document.getElementById('bar-high').style.width = Math.min((dHigh/10)*100, 100) + '%';
                document.getElementById('bar-low').style.width = Math.min((dLow/10)*100, 100) + '%';
                document.getElementById('ratio-text').innerText = `Ratio: ${ (dHigh>0 ? (dLow/dHigh) : 0).toFixed(2) }`;
            }
        }

        function updateMatrixTexture() {
            matCtx.fillStyle = '#000'; matCtx.fillRect(0,0,512,512);
            matCtx.font = '20px monospace';
            for(let r=0; r<20; r++) for(let c=0; c<20; c++) {
                const val = Math.random()>0.6 ? (Math.random()>0.5?'1':'-1') : '0';
                matCtx.fillStyle = `rgba(255,255,255,${Math.random()})`;
                matCtx.fillText(val, c*25 + Math.random()*5, (r*25 + Date.now()*0.05)%512);
            }
            matrixTexture.needsUpdate = true;
        }

        // --- POST PROCESSING (DITHERPUNK) ---
        const ditherMat = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2() } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; varying vec2 vUv;
                float find_closest(int x, int y, float v) {
                    float dither[64] = float[](
                        0.0, 32.0, 8.0, 40.0, 2.0, 34.0, 10.0, 42.0, 48.0, 16.0, 56.0, 24.0, 50.0, 18.0, 58.0, 26.0,
                        12.0, 44.0, 4.0, 36.0, 14.0, 46.0, 6.0, 38.0, 60.0, 28.0, 52.0, 20.0, 62.0, 30.0, 54.0, 22.0,
                        3.0, 35.0, 11.0, 43.0, 1.0, 33.0, 9.0, 41.0, 51.0, 19.0, 59.0, 27.0, 49.0, 17.0, 57.0, 25.0,
                        15.0, 47.0, 7.0, 39.0, 13.0, 45.0, 5.0, 37.0, 63.0, 31.0, 55.0, 23.0, 61.0, 29.0, 53.0, 21.0
                    );
                    return v < (dither[(x%8)+(y%8)*8]/64.0) ? 0.0 : 1.0;
                }
                void main() {
                    vec4 c = texture2D(tDiffuse, vUv);
                    float l = dot(c.rgb, vec3(0.299, 0.587, 0.114));
                    gl_FragColor = vec4(mix(vec3(0), vec3(0.2, 1.0, 0.0), find_closest(int(gl_FragCoord.x), int(gl_FragCoord.y), l)), 1.0);
                }
            `
        });
        const ppScene = new THREE.Scene();
        const ppQuad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), ditherMat);
        ppScene.add(ppQuad);
        const ppCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

        // --- RESIZE LOGIC ---
        function onWindowResize() {
            // Get dimensions of the CANVAS CONTAINER, not the window
            const width = container.clientWidth;
            const height = container.clientHeight;
            const aspect = width / height;

            // Simple Zoom logic: if aspect < 1 (narrow), zoom out to fit width
            const baseFrustum = 30;
            const frustumSize = aspect < 1 ? (baseFrustum / aspect) : baseFrustum;

            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();

            const pRatio = Math.min(window.devicePixelRatio, 2);
            renderer.setSize(width, height);
            renderer.setPixelRatio(pRatio);
            renderTarget.setSize(width * pRatio, height * pRatio);
            ditherMat.uniforms.tDiffuse.value = renderTarget.texture;
            ditherMat.uniforms.resolution.value.set(width * pRatio, height * pRatio);
        }

        window.addEventListener('resize', onWindowResize);
        document.getElementById('btn-reroll').addEventListener('click', randomizeMatrix);
        randomizeMatrix();
        onWindowResize(); // Init

        function animate() {
            requestAnimationFrame(animate);
            updateMatrixTexture();
            updateProjection();
            renderer.setRenderTarget(renderTarget);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            renderer.render(ppScene, ppCamera);
        }
        animate();
    </script>
</body>
</html>